1. -----Создание веб-сайта на Java-----
Для того чтобы создать Spring проект, нужно зайти на сайт-конструктор start.spring.io - Artifact-id означает название корневой папки(проекта), Group-id - папка(/папки), в которых хранится код
Скачиваем архив и распаковываем его
MVC - Model-View-Controller - схема проектирования, позволяющая разбить все файлы на три категории: модели, шаблоны и контроллеры
В контроллерах происходит отслеживание url-адресов и их переходов, контроллер может обращаться к модели, которая к чему-то относится(БД, тд...)
Шаблон - определенный вид сайта, который показывается пользователю(в html, css виде)
Пока что это сырой проект: чтобы он запускался, нужно перейти на сайт spring.io в раздел "Guides", ввести "mvc", перейти по ссылке и оттуда скопировать все зависимости в pom.xml, удалив старые
Нажимаем на кнопку "Синхронизировать файлы" внизу в VSCode
2. -----Главная страница сайта-----
Проект есть, однако в нем нет ни одного шаблона
Все еще используем официальную документацию (ссылка с предыдущего урока)
Первый делом надо создать шаблон главной страницы: для этого в Group-id(папка, в которой есть main) создаем папку "templates", в ней создаем файл "MainController.java"(всё можно называть как угодно), копируем в него текст с контроллера "Create a Web Controller"
В параметрах функции убираем аннотацию, оставляем только Model
В аннотации @GetMapping указывается обрабатываемый url-адрес
Эта функция нужна для последующей обработки перехода url-страницы в html - файле - из этой функции мы возвращаем строку с названием шаблона страницы (без .html), потом нужно будет создать шаблон с таким названием
В документации есть пример шаблона с последующим его расположением: в теле <body> есть строка "Hello, <параметр>": вместо параметра нужно вставить переменную, которую изначально вставили в модель контроллера
Проект готов: чтобы его запустить переходим в BlogApplication и нажимаем Debug, а потом Run либо любую другую кнопку запуска (если нет IDE, то нужно создавать проект maven самостоятельно, а я не хочу, так что обойдусь так)
Если ничего не заработало, это означает, что порт 8080 используется другой веб-страницей, значит надо перенаправить localhost: заходим в ..resourses/templates/application.propoerties и пишем в нем "server.port = 8081". Компилируем заново
Для просмотра веб-сайта заходим в браузер и пишем в строке поиска "localhost:8081"
На этом этапе сайт выглядит убого, поэтому вместо писанины на html можно использовать готовые шаблоны: заходим на getbootstrap.com(содержит множество готовых html, css, js стилей), вкладка "examples", заходим в понравившийся шаблон, открываем панель разработчика, с помощью указателя копируем код шапки и содержимого страницы, пихаем в <body>. Видим, что страница высвечивается без каких-либо стилей: это логично, так как мы не подключали никаких стилей.
Чтобы включить css, заходим на bootstrapcdn.com, копируем первую строку, в теге <head> прописываем тег <link>(vscode автодополняет его) и вставляем эту строку в атрибут href
Потом так же копируем основную часть и вставляем html код
Пока что мы отслеживаем только главную страницу
3. -----Разработка раздела "Блог"-----
Для новой страницы нужно добавить новый контроллер, прописываем аннотацию @Controller, затем @GetMapping("отслеживаемый url страницы, на которую нужно перейти")
Внутри функции принимаем Model model, возвращаем название веб-страницы в виде строки и создаем шаблон с таким же названием в html
Предполагается, что на любой странице должен быть повторяющийся элемент, например, шапка сайта или футер
Повторяющиеся секции лучше всего выносить в отдельные шаблоны(файлы html), так как во-первых, так проще их импортировать, а во-вторых, так проще вносить изменения, чтобы вносить изменения в один файл, а не во все остальные
Для этого создаем в templates папку, например, "blocks": там будут храниться все секции, там создаем header.html, в него копируем шапку: надо также указать, что этот шаблон является вставляемым (<div th:fragment = "header">...</div>), а потом в <body> вставляем примерно вот это: <header th:insert="blocks/header :: header"></header>(тэг может быть не только header)(надо изучить thymeleaf)
Кстати, в href шапки можно менять ссылки
4. -----Работа с БД MySQL. Создание модели-----
Для того чтобы подключить необходимые зависимости для подключения к БД, заходим в pom.xml, копируем оттуда любую зависимость с <scope>runtime</scope> и меняем только <artifactId>spring-boot-starter-data-jpa</artifactId> - мы подключили jpa, осталось подключить коннектор
Снова вставляем зависимость и исправляем на <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId>, <scope> оставляем таким же
Теперь нужно указать само подключение к БД: заходим в application.properties, затем переходим по ссылке spring.io/guides, прописываем mysql в строке поиска, переходим по ней и копируем строки из документации
Меняем данные, как хотим
После этого создаем базу с нужным названием и создаем под нее нового пользователя

mysql> create database db_example; -- Creates the new database
mysql> create user 'springuser'@'%' identified by 'ThePassword'; -- Creates the user
mysql> grant all on db_example.* to 'springuser'@'%'; -- Gives all privileges to the new user on the newly created database

В видео чел советует скачать mamp, чтобы во время работы создавался локальный сервер, но при установке workbench у меня он уже стоит (mysqld.exe), так что я этот шаг пропущу
Так же он оперирует с БД с помощью phpMyAdmin, но у меня уже есть WorkBench
Я захожу в workbench, чтобы создать новое соединение под нового пользователя (можно найти в гугле за минуту, как это сделать). В соединении нового пользователя появляется пустая ранее созданная таблица
Чтобы создать модель для работы с БД, создаем новую папку models там же, где и папка controllers, в ней создаем файл Post.java (этот класс хранит структуру всех статей на сайте)
В этот класс можно внести, например, ID, название, анонс(вступительный текст), содержание статьи и кол-во просмотров
Аннотируем этот класс как сущность в БД(кроме класса и ID можно ничего не аннотировать, ведь табличка создатся автоматически) и добавляем геттеры и сеттеры
Если прямо сейчас запустить приложение, то в БД создастся пустая табличка Post(проверка работоспособности), однако пока что мы не можем работать с этой моделью через приложение
Для манипулирования данными в БД нужно создать интерфейс(репозиторий), с помощью которого можно изменять, удалять информацию в конкретной(!) табличке
Для этого создаем новую папку repos там же, где controllers и models(для каждой модели надо создавать новый репозиторий), в ней создаем интерфейс PostRepository.java, расширяем его от интерфейса CrudRepository: в параметрах CrudRepository указываем класс Post(так как этот интерфейс работает с конкретной моделью), а так же тип уникального идентификатора (у меня это Long)
Переходим в BlogController и в blogmain будем передавать все записи, которые будем получать из таблички Post
Чтобы передавать все записи в шаблон, нужно создать переменную, которая будет ссылаться на репозиторий
Передаем аннотацию @Autowired
private PostRepository postRepository;
Теперь внутри функции создаем объект на основе Iterable(массив данных, полученный из определенной таблички в БД)
Iterable<Post> posts = postRepositiory.findAll();
Потом необходимо прописать обращение к 
model.addAttribute("posts", posts);(передаем по имени "posts", в качестве значения передаем массив - это нужно для вывода информации в html)
Переходим в blog-main.html и выводим данные с помощью цикла
Теперь можно запустить и проверить работоспособность
На этом этапе можно внести в саму БД данные, они выведутся на странице сайта
5. -----Форма добавления записей через сайт-----
Убедитесь в том, что локальный сервер запущен (у меня он запущен с включением компьютера)
Заходим в blocks/header.html и вставляем новую ссылку "Добавить статью"
Заходим в BlogController и отслеживаем новый url-адрес, добавив функцию blogAdd - создаём шаблон blog-add.html
Меняем основную часть, добавив форму для добавления статьи: для этого надо знать html, здесь лучше посмотреть Дударя
После создания формы если нажать кнопку "Добавить статью", вылезет ошибка, так как эта форма никак не обрабатывается: нужно отследить url-адрес /blog/add
Сейчас мы будем получать данные при помощи "post"-данных (в blog-add.html мы указали способ передачи данных как post)
Поэтому мы можем создать новый обработчик url-адреса в BlogController.java с помощью @PostMappring(url) - в таком случае мы получаем данные из формы, а не через переход на страницы
Пишем такую же функцию, как blogAdd(), только с другим названием
Чтобы получить данные из формы, в параметрах функции прописываем аннотацию @RequestParam String title(название берется из blog-add.html, где мы указывали имя строки, в которую вписывается название статьи)
Создаем объект на основе модели Post, в него передаем название, вступление и полный текст с помощью конструктора: конструктора у нас пока что нет, так что идем в Post.java и создаем его там (также в любой модели должен быть пустой конструктор, это важно!)
Переходим обратно и обращаемся к репозиторию postRepository и функции save, чтобы сохранить объект(сущность) в БД
Не забываем про параметр return: он должен возвращать шаблон - можно снова указать return "blog-add"; , но так не интересно, и хочется, чтобы после добавления статьи происходила переадресация на страницу с блогами: 
return "redirect:/blog";
Если прямо сейчас запустить приложение и попытаться добавить статью, то ничего не выйдет, так как есть проблема с уникальной идентификацией объекта в БД(два объекта с id=1): чтобы решить эту проблему, достаточно удалить статью из предыдущего урока: тогда БД станет пустой и не будет конфликта: теперь можно запускать проект
6. -----Вывод каждой из статей-----
Необходимо создать шаблон, который будет обрабатывать страничку, где в динамическом формате будет подставляться номер статьи
Пока что у нас есть только ссылка, без обработчика
Необходимо отслеживать адрес "/blog/{id}", где id-динамический номер статьи в БД
В параметрах функции принимаем модель и переменную id:
@PathVariable(value = "id") long id, Model model
Обращаемся к postRepository.findById(id), чтобы найти сущность по ее Id. Эту переменную надо помещать в объект на основе Optional<Post(с какой моделью работаю)> post = ...
Теперь этот объект стоит привести к ArrayList: 
List<Post> res = ArrayList<>();// просто выделили память
post.ifPresent(res::add);// надо указать, что из класса Optional переводим в ArrayList(понятия не имею, почему здесь двойное двоеточие). Остается прописать
model.addAtribute("post", res); // "post" передается в шаблон, как объект res
Возвращаем return "blog-details"; и создаем шаблон blog-details.html в templates
Копируем в него код из blog-main.html и меняем содержимое: теперь здесь перебираем не "posts", а "post", так как именно по этому имени передается объект
Добавляем кнопки "Редактировать" и "Удалить" и полный текст статьи
Можно запускать
Если в адресной строки вместо id записать любое число, адрес все равно обработается, так что в таком случае придется перенаправлять пользователя на страницу со всеми статьями
if (!postRepository.existsById(id)) return "redirect:/blog"; 